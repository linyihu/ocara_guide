<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>动作action的使用</title>
<script type="text/javascript" src="../syntax/scripts/shCore.js"></script>
<script type="text/javascript" src="../syntax/scripts/shBrushPhp.js"></script>
<script src="../treeview/lib/jquery.js" type="text/javascript"></script>
<script src="../treeview/lib/jquery.cookie.js" type="text/javascript"></script>
<script src="../treeview/jquery.treeview.js" type="text/javascript"></script>
<link type="text/css" rel="stylesheet" href="../style/base.css" />
<link type="text/css" rel="stylesheet" href="../style/function.css" />
<link type="text/css" rel="stylesheet" href="../syntax/styles/shCoreDefault.css"/>
<link rel="stylesheet" href="../treeview/jquery.treeview.css" />
<link type="text/css" rel="stylesheet" href="../style/plugin.css" />
<script type="text/javascript" src="../treeview/base.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  
 $("#browser").treeview({
  persist: "location",
  collapsed: false,
  unique: true
 });
});
</script>
</head>
<body><pre><h2>控制器动作（Action）</h2>
        
         Ocara的action打破了传统框架的陈规，将action独立成类，避免了一个控制器多个action写在一个文件的笨重性，提高
了代码的可读性。当然，如果action的代码很少，依然可以写在控制器文件。
         如果一个action同时使用了上述2种方式，<b>Ocara会优先使用写在控制器文件中的action函数</b>，同名的action类将不调用。
		 
<h2>第1种 Action独立成类（默认、推荐）</h2>

  适合于代码较多的情况。
</pre>

  <table class="hint">
	<tr class="head">
		<td><h2>特色：</h2>action类文件都放在控制器的Action目录中，每个action类都必须继承它的控制器类。</td>
	</tr>
</table>
<pre>
    <strong>实例如下</strong>。
    假设有个商品控制器命名为item，要进行list（列表）、create(新建）、update(更新)和del（删除）操作。
  
    <strong>其目录结构如下所示</strong>：
</pre>
<ul id="browser" class="filetree">
	<li><span class="folder">application</span>
	<ul>
		<li><span class="folder">controller</span>
			  <ul>
					<li><span class="folder">Item（item控制器目录）</span>
						<ul>
							<li><span class="file">Item.php（item控制器文件录）</span></li>
							<li><span class="folder">Action（action目录，其下面保存了item控制器的动作类）</span>
							<ul>
								<li><span class="file">Index.php（index动作文件）</span></li>
								<li><span class="file">Create.php（create动作文件）</span></li>
								<li><span class="file">Update.php（update动作文件）</span></li>
								<li><span class="file">Delete.php（delete动作文件）</span></li>
							</ul>
						</li>
						</ul>
					</li>
			  </ul>
		</li>
	</ul>
</li>
</ul>

<pre>

     <strong>说明如下：</strong>
     其中，Item.php是控制器文件，定义了ItemController类，如下代码:
<pre class="brush: php;"> class ItemController extends Controller 
{
    //控制器初始化函数
    protected function _control(){}  
}
 </pre>
     Action目录下面都是item控制器的action类，比如Index.php定义了IndexAction类，如下代码所示：
 <pre class="brush: php;"> class IndexAction extends HomeController 
 {
     //动作初始化函数
     protected function _action(){}  
 }
 </pre>
     IndexAction就是index动作，继承了ItemController控制器类。
 
    <strong>实例总结</strong>
    也就是说，对于此例，我们要新建ItemController控制器类，还有四个ListAction、CreateAction、UpdateAction和DelAction动作类，都保存在在item控制
器的Action目录中，并且分别命名为List.php、Create.php、Update.php和Del.php。

<h2>第2种 Action直接写在控制器文件</h2>

  适合于代码较少的情况。
</pre>

  <table class="hint">
  <tr class="head">
		<td><h2>特色：</h2>
		直接写成控制器的方法函数。方法名必须以小写action与首字母大写的动作名组成。</td>
	</tr>
</table>
<pre>
   例如上面例子中的index动作，可以在ItemController控制器中新建IndexAction的方法函数，所有代码都写在其中。
   如下所示：
<pre class="brush: php;"> class ItemController extends Controller 
{
	//控制器初始化函数
    protected function _control(){}  
	 
	//index方法直接写在控制器的情况
    public function IndexAction()
	{	
       //这里写index动作的代码
	} 
}
 </pre>
<h2>Action类介绍</h2>

<strong>1、新建Action类</strong>
    一般，每个控制器目录下面会有一个Action目录。如果您的action代码很多，建议您将action独立成类写在该目录中。
   Action类名格式：
</pre>
     <table class="hint">
	<tr class="head">
	  <td><h2>Action类名格式：</h2>	    类名必须以首字母大写的Action和首字母大写的动作名组成。</td>
	</tr>
</table>
<pre>
    实例：
         home的index动作，如下代码（保存在controller/Home/Action目录）：
<pre class="brush: php;">
class IndexAction extends HomeController
{
   //初始化函数
   protected function _action(){}
}
</pre>
  <strong>2、结构控制函数</strong><div class="function">
     如果action是独立成类的。那么我们的代码就变得更加美观和易于维护，因为在该类中我们可以使用以下方法函数进行编程：
     <strong>（1）_action()</strong>
             用于写初始化代码（类似于类的析构函数）。这个方法会首先执行，因此不需要新建_construct()函数，以免覆盖父级类的析构函数。
             如下实例：
<pre class="brush: php;">
	protected function _action()
	{
		$this->model = $this->model();
	}
</pre>
     <strong>（2）_form()</strong>
             用于表单的新建。
             一般地，表单统一是在本函数当中新建，可以新建多个表单，当然在其他地方也是可以的。
             如下实例：
<pre class="brush: php;">
	protected function _form()
	{
		$this->form('form_edit')
		     ->init(
		     	 //表单的action
		         ocUrl('/admin/item/update'), 
		         //表单的其他属性
			     array(                       
			     	'enctype' => "multipart/form-data",
					'onsubmit' => 'return validateForm(this)'
			     )
		     );
	}
</pre>   
     <strong>（3）_display()</strong>
              用于输出模板，用于在表单提交之前。没有表单提交时，都会执行该方法。
              因此，如果要输出html，就在这里写输出前的逻辑处理代码，包括表单的输出。当表单提交后，一般是在_submit()方法中处理。
              如下实例：
<pre class="brush: php;">
	protected function _display()
	{
		$id = $this->request->getGet('id');
		
		if (empty($id)) {
			die('参数非法！');
		}
		
		//获取商品信息
		$data = Item::select($id)->getData();
		$this->assign(compact('data'));
	}
</pre>
     <strong>（4）_submit()</strong>
             用于表单提交后的处理。当表单提交表单后，就在这里写后台处理代码。
             表单提交一般都是POST方式。
             如果是GET方式提交的，请使用_isSubmit()函数去编写判断表单是否提交的代码，参见<a href="../视图层/表单生成.html" title="表单生成">表单生成</a>第三第2点。
             如下实例：
<pre class="brush: php;">
	protected function _submit()
	{
		$id = Request::getGet('id');
		
		if (empty($id)) {
			die('参数非法！');
		}
		
		//获取POST数据，新建ORM模型
		$model = $this->model();
		$model->data();
		
		//设置最后修改时间为当前时间
		$model->create_time = ocSql('now()');
		
		//更新记录
		$model->save();
		
		die('Update Success!');
	}
</pre>
     <strong>（5）_isSubmit()</strong>
             用于手动判断表单是否提交。
             若Action类中没有该方法函数，默认是使用框架的Request::isPost()来检测的；如果不合适，可以新建该函数去检测，然后return true/false即可。
             如下实例：
<pre class="brush: php;">
	protected function _isSubmit()
	{
	    //重写表单是否提交的判断
		return $this->request->isPost() && array_key_exists('submit_button_name', $_POST);
	}
</pre>
     <strong>（6）_ajax()</strong>
             用于ajax提交的后台代码处理。框架中使用Request::isAjax()判断是否是ajax提交的。
             如下实例：
<pre class="brush: php;">
protected function _ajax()
{
	$id = $this->request->getGet('id');

	if (empty($id)) {
		$this->error->show('删除失败！');
	}

	$result = Item::select($id)->delete();
	$this->ajaxReturn($result, '删除成功！');
}
</pre>
     <strong>（7）_after()</strong>
             用于动作执行完成以后的代码，一般框架_display()、_submit()和_ajax()执行完以后会自动执行。
             所以如果该方法存在的话，上述其他任何方法在停止代码执行时，除非是抛出错误提示或者不想调用该方法，否则尽量执行一下该方法。
             如下实例：
<pre class="brush: php;">
	protected function _after()
	{
		//这里写Action执行完以后的代码
	}
</pre>
             使用上述7个函数，您的代码将变得更加有条理。其中_after()、_isSubmit()一般要手动添加。
</div>
      <strong>3、结构控制函数的执行顺序</strong>
             上面几个结构型函数执行顺序是怎么样的呢？ 按优先级从高到低的顺序，如下所示：
             _action() -> _form()-> _isSubmit() -> _display()或_submit()或_ajax() -> _after()
</pre>
</body></html>
