<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>依赖注入容器</title>
<script type="text/javascript" src="../syntax/scripts/shCore.js"></script>
<script type="text/javascript" src="../syntax/scripts/shBrushPhp.js"></script>
<link type="text/css" rel="stylesheet" href="../style/base.css" />
<link type="text/css" rel="stylesheet" href="../style/function.css" />
<link type="text/css" rel="stylesheet" href="../syntax/styles/shCoreDefault.css"/>
<script type="text/javascript" src="../treeview/base.js"></script>
<style type="text/css">
    <!--
    .STYLE1 {
        color: #0000FF;
        font-weight: bold;
    }
    -->
</style>
</head><body><pre><h2>依赖注入容器</h2>

      依赖注入容器，可以实现类或接口的绑定、实例化或实现，以及依赖管理。

<strong>1、容器的使用</strong>
      （1）默认容器
            框架开始时便生成了一个默认容器，该容器保存在\Ocara\Base::$container属性中。因此有以下使用方法:
            （a）任意处可以使用\Ocara\Base::$container来调用默认容器。
                  实例如下：
<pre class="brush: php;">
//使用Base::$container
$container = Base::$container;
</pre>
            （b）在继承了\Ocara\Base的类中，可以使用self::$container来调用默认容器。
                  框架的每个类，都继承了\Ocara\Base，所以控制器动作或Model中，都可以使用self::$container来调用默认容器。
                  实例如下：
<pre class="brush: php;">
//继承自Base的类中使用
class test extends \Ocara\Base
{
    public function output()
    {
       $response = self::$container->response;
    }
}
</pre>
                  Model中使用默认容器，实例如下：
<pre class="brush: php;">
use Ocara\Model\Database as DatabaseModel;

class User extends DatabaseModel
{
	/**
	 * 初始化
	 */
	public function _model()
	{
        $session = self::$container->session;
    }
}
</pre>
            （c）控制器动作中使用默认容器
                  可以使用self::$container，也可以使用“$this->属性名”方式获取绑定类。
                  实例如下：
<pre class="brush: php;">
class EditAction extends ItemController
{
	/**
	 * 初始化
	 */
	public function _action()
	{}

	public function _form()
	{}

	public function _display()
	{
        $id = self::$container->request->getGet('id'); //使用self::$container
        $id = $this->request->getGet('id'); //直接使用$this->request可以获取容器中的request实例
    }

	public function _submit()
	{
        $data = self::$container->request->getPost();
        $data = $this>request->getPost();
    }
}
</pre>
      （2）生成新的容器
            除了使用默认容器，我们还可以新建一个容器，只要新建\Ocara\Container类即可。
            如下所示：
<pre class="brush: php;">
//使用new 关键字新建容器
$container = new \Ocara\Container();

//使用build()方法新建容器
$container = \Ocara\Container::build();
</pre>

<strong>2、类或接口的绑定</strong>
      （1）动态绑定
            动态绑定使用容器的bind()方法，也可以使用容器的属性来操作。
                  <span class="STYLE1">bind(name, source[, params, deps])</span>
            参数说明：
</pre>
<table>
    <tr class="head">
        <td width="90">名称</td>
        <td width="400">描述</td>
    </tr>
    <tr>
        <td>name</td>
        <td>必需。绑定名称或类名、接口名。</td>
    </tr>
    <tr>
        <td>source</td>
        <td>必需。实例化来源。可以是类和方法的数组、回调函数或类名字符串。</td>
    </tr>
    <tr>
        <td>params</td>
        <td>可选。类的构造函数的前面部分参数。会与get()方法中传递的后面函数合并。</td>
    </tr>
    <tr>
        <td>deps</td>
        <td>可选。属性注入数组。键名是属性名称，键值是注入的对象。<br/>
            使用前提是类中必须包含该属性名称的set和get方法。<br/>
            比如，Computer类中要使用属性注入的方式向它的mouse属性为一个Mouse类，需要在它内部定义一个setMouse()和getMouse()方法。
        </td>
    </tr>
</table>
<pre>
            实例如下：
</pre>
<pre class="brush: php;">
//方法数组
Base::$container->bind('userChecker', array('User', 'getChecker'));

//回调匿名函数
Base::$container->bind('userChecker', function(){
    return User::getChecker();
});

//获取类名
Base::$container->bind('userChecker', '\User\Checker');

//用类实现接口
Base::$container->bind('\Interface\User\Checker', '\User\Checker');

//用新类替换被绑定的类
Base::$container->bind('\User\Checker', '\User\NewChecker');
</pre>
<pre>
            另外，可以不用bind()方法，直接使用未定义的属性来绑定。实例如下：
</pre>
<pre class="brush: php;">
//方法数组
Base::$container->userChecker = array('User', 'getChecker');

//回调函数
Base::$container->userChecker = function(){
    return User::getChecker();
};

//获取类名
Base::$container->userChecker = '\User\Checker';
</pre>

<pre>
      （2）单例模式绑定
            与动态绑定区别在于：动态绑定的类可以通过容器的create()方法多次新建一个实例，但是单例模式绑定的则不能，只会在第一次使用时自动create()一次。
                  <span class="STYLE1">bindSingleton(name, source[, params, deps])</span>
            参数和实例同上。
</pre>
<pre>

<strong>3、绑定类的使用</strong>
      使用容器的get()方法，或者使用容器绑定过的名称属性，就可以获取实例化后的绑定类。
      （1）使用get()方法
                  <span class="STYLE1">get(name[, params, deps])</span>
            参数说明：
</pre>
<table>
    <tr class="head">
        <td width="90">名称</td>
        <td width="400">描述</td>
    </tr>
    <tr>
        <td>name</td>
        <td>必需。绑定名称或类名。</td>
    </tr>
    <tr>
        <td>params</td>
        <td>可选。类的构造函数的后面部分参数。会与bind()或bindSingleton()中指定的前面参数合并</td>
    </tr>
    <tr>
        <td>deps</td>
        <td>可选。属性注入数组。同上bind()或bindSingleton()中的deps参数，最后会将两者进行合并使用。</td>
    </tr>
</table>
<pre>
            实例如下：
</pre>
<pre class="brush: php;">
$userChecker = Base::$container->get('userChecker');
</pre>
<pre>
      （2）使用未定义的属性
            使用容器中未定义的绑定名称属性， 也可以实现在同样的效果。
            上述实例等同于：
</pre>
<pre class="brush: php;">
$userChecker = Base::$container->userChecker;
</pre>

</pre>
</body></html>
