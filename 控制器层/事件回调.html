<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>事件回调</title>
<script type="text/javascript" src="../syntax/scripts/shCore.js"></script>
<script type="text/javascript" src="../syntax/scripts/shBrushPhp.js"></script>
<link type="text/css" rel="stylesheet" href="../style/base.css" />
<link type="text/css" rel="stylesheet" href="../syntax/styles/shCoreDefault.css"/>
<script type="text/javascript" src="../treeview/base.js"></script>
<style type="text/css">
<!--
.STYLE1 {
	color: #0000FF;
	font-weight: bold;
}
-->
</style>
</head>

<body><pre><h2>事件回调</h2>

<strong>一、事件介绍</strong>
         通常在业务代码的某个位置可能会调用一个回调函数去处理业务，从而实现业务处理的自定义，并达到解耦目的。
         这样一种回调处理需要在某个位置进行触发，使用事件。比如前端页面中某个按钮的单击事件，会回调某一个函数做某些操作。
         在事件处理机制中，有三个角色：
                  （1）触发事件的源对象：按钮的单击事件中，按钮就是觖发事件的源对象
                  （2）事件对象：按钮的单击这个事件可以定义为一个对象实例，用于面向对象化处理。
                  （3）事件回调函数：按钮的单击事件触发后要执行的每个操作，可以添加多个回调函数来执行。

<strong>二、注册和获取事件</strong>
        使用本框架时，任何一个类必须继承自<span class="STYLE1">Ocara\Core\Base</span>，才添加事件处理。
<pre class="brush: php;">
class Test extends Ocara\Core\Base
{}
</pre>
        这些类都包含以下事件处理函数。
        （1）注册事件
                <span class="STYLE1">registerEvents()</span>
<pre class="brush: php;">
class Test extends Ocara\Core\Base
{
    /**
     * 注册事件
     */
    public function registerEvents()
    {
         $this->event('updateStatus')  //新建和调用updateStatus事件对象
              ->append(array($this, 'updateStatusCallback')); //添加处理器
    }

}
</pre>
        （2）添加或获取事件
                使用event()可以获取事件，如果没有添加该事件则会自动添加该事件。
                <span class="STYLE1">event(eventName)</span>
                其中的eventName参数就是事件名称。
<pre class="brush: php;">
    public function registerEvents()
    {
         $this->event('updateStatus')  //新建和调用updateStatus事件对象
              ->append(array($this, 'updateStatusCallback')); //添加处理器
    }
</pre>
        （3）预先设置事件
                除了使用event()来添加或获取事件，还可以在外层预先设置事件。
                <span class="STYLE1">event+事件名称(eventName)</span>
                其中事件名称首字母要大写。
<pre class="brush: php;">
class IndexController extends Module
{
    public function __action()
    {
         Test::eventUpdateStatus()  //新建和调用updateStatus事件对象
              ->append(array($this, 'updateStatusCallback')); //添加处理器
    }
}
</pre>

<strong>三、添加事件回调函数</strong>
        1、单个添加回调函数或对象
                使用append()方法注册回调函数，可以注册多次。
                        <span class="STYLE1">append(callback[, args])</span>
                其中,callback是回调函数，和call_user_func_array()类似，指定的是函数名、方法数组，还可以是类名或对象。
                （1）回调函数

<pre class="brush: php;">
namespace app\services;

use Base\DatabaseModel;

class OrdersService extends DatabaseModel
{
    public function registerEvents()
    {
        //注册事件和处理器
        $this->event('afterUpdateStatus')
             ->append('writeUserLog') //指定已存在的函数名
             ->append(array('\app\services\UserLog', 'writeLog')); //指定方法名
    }
}
</pre>
                         以下是其中\app\services\UserLog的writeLog回调函数：

<pre class="brush: php;">
use Ocara\Core\Base;

class UserLog extend Base
{
    /**
     * 事件回调处理函数
     */
    public function writeLog($order, $oldStatus, $event)
    {
         /*记录订单状态日志*/
         $this->log->writeLog('order ' . $order->id . ' is successly updated to ' . $oldStatus);
    }
}
</pre>
                （2）回调类或对象
                        除此以外，框架还支持直接指定一个类或对象，然后回调它的handle()方法。
<pre class="brush: php;">
    public function registerEvents()
    {
        //注册事件和处理器
        $this->event('afterUpdateStatus')
             ->append('\app\services\OrderStatusLog') //指定类名
             ->append(new \app\services\OrderStatusLog()); //指定对象
    }
</pre>
                        这个对象类必须继承Ocara\Core\Middleware中间件基类。
                                <span class="STYLE1">handle(params, ... [,event , eventTarget])</span>
                        前面参数是每个事件调用时传递的自定义参数。
                        最后的两个参数必是evnet和eventTarget，分别是事件对象和触发事件的源对象，可选参数。
<pre class="brush: php;">
namespace Events\Callback;

use Ocara\Core\Middleware;

class OrderStatusLog extends Middleware
{
    /**
     * 事件回调处理函数
     */
    public function handle($order, $oldStatus, $event)
    {
         /*存入订单状态日志表*/
         $orderStatus = new \app\model\database\OrderStatusLog();
         $orderStatus->oldStatus = $oldStatus;
         $orderStatus->newStatus = $order->status;
    }
}
</pre>
        2、批量绑定回调函数
                还可以用bindEventHandler()绑定一个对象，它包含了与事件名称相同的方法函数，可以批量添加回调函数。
                注：append()和bindEventHandler()可以同时使用，会按先后顺序添加回调函数。
                        <span class="STYLE1">bindEventHandler(eventHandler)</span>
                其中eventHandler可以是类名或对象。

<pre class="brush: php;">
namespace User;

/**
 * 用户事件处理器
 */
class UserHandler extends DatabaseModel
{
    /**
     * 显示前
     */
    public function beforeShow($userName, $event, $eventTarget)
    {
        echo 'beforeShow', PHP_EOL;
    }

    /**
     * 显示完
     */
    public function afterShow($userName, $event, $eventTarget)
    {
       echo 'afterShow';
    }

    public function other()
    {
       echo 'other';
    }
}

class User extends Base
{
    public function __construct()
    {
        $userModel->bindEventHandler('\User\UserHandler'); //用类名绑定处理器对象
        $userModel->bindEventHandler(new \User\UserHandler()); //用对象绑定处理器对象
    }

    public function show($userName)
    {
         $this->fire('beforeShow', array($userName)); //触发显示前事件
         echo $userName, PHP_EOL;
         $this->fire('afterShow', array($userName)); //触发显示后事件
    }
}

$user = new User();
$user->show('user1');
</pre>
                会显示为：
                beforeShow
                user1
                afterShow

<strong>四、事件触发</strong>
        <span class="STYLE1">fire(eventName[, params])</span>
        其中，eventName是事件名称，params是触发时传递给回调函数的参数。

<pre class="brush: php;">
namespace app\services;

use Base\DatabaseModel;

class OrdersService extends DatabaseModel
{
    public function updateStatus($orderId, $extraData)
    {
        $order = new \app\model\database\Orders();
        $order->select($orderId);

        $oldStatus = $order->status;
        $newStatus = 1;

        $order->status = $newStatus;
        $order->save($extraData);

        //触发事件
        $args = array($order, $oldStatus);
        $order->fire('afterUpdateStatus', $args);
    }
}
</pre>

<strong>五、事件中断</strong>
        在事件的多个处理器中，可以使用stop()来中断事件的执行。
                <span class="STYLE1">stop()</span>

        使用isRunning()判断是否在运行中
                <span class="STYLE1">isRunning()</span>

<pre class="brush: php;">
namespace app\services;

class OrderStatusLog
{
    public function handle($order, $oldStatus, $event)
    {
        if (empty($orderId)){
            $event->stop(); //中断事件
        }

        if ($event->isRunning()) { //事件是否在运行中
             /*存入订单状态日志表*/
        }
    }
}
</pre>

</pre>
</pre>
</body>
</html>
