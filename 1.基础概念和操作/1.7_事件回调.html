<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>1.7 事件回调</title>
<script type="text/javascript" src="../syntax/scripts/shCore.js"></script>
<script type="text/javascript" src="../syntax/scripts/shBrushPhp.js"></script>
<link type="text/css" rel="stylesheet" href="../style/base.css" />
<link type="text/css" rel="stylesheet" href="../syntax/styles/shCoreDefault.css"/>
<script type="text/javascript" src="../treeview/base.js"></script>
<style type="text/css">
<!--
.STYLE1 {
	color: #0000FF;
	font-weight: bold;
}
-->
</style>
</head>

<body><pre><h2>1.7 事件回调</h2>

<strong>一、事件介绍</strong>
         通常在业务代码的某个位置可能会调用一个回调函数去处理业务，从而实现业务处理的自定义，并达到解耦目的。
         这样一种回调处理需要在某个位置进行触发，使用事件。比如前端页面中某个按钮的单击事件，会回调某一个函数做某些操作。
         在事件处理机制中，有三个角色：
                  （1）触发事件的源对象：按钮的单击事件中，按钮就是觖发事件的源对象
                  （2）事件对象：按钮的单击这个事件可以定义为一个对象实例，用于面向对象化处理。
                  （3）事件回调函数：按钮的单击事件触发后要执行的每个操作，可以添加多个回调函数来执行。

<strong>二、注册和获取事件</strong>
        使用本框架时，任何一个类必须继承自<span class="STYLE1">Ocara\Core\Base</span>，都可以使用本文说明的事件处理。
<pre class="brush: php;">
class Test extends Ocara\Core\Base
{}
</pre>
        这些类都包含以下事件处理函数。
        （1）注册事件
                <span class="STYLE1">registerEvents()</span>
<pre class="brush: php;">
class Test extends Ocara\Core\Base
{
    /**
     * 注册事件
     */
    public function registerEvents()
    {
         $this->event('updateStatus')  //新建和调用updateStatus事件对象
              ->append(array($this, 'updateStatusCallback')); //添加处理器
    }

}
</pre>
        （2）添加或获取事件
                使用event()可以获取事件，如果没有添加该事件则会自动添加该事件。
                <span class="STYLE1">event(eventName)</span>
                其中的eventName参数就是事件名称。
<pre class="brush: php;">
    public function registerEvents()
    {
         $this->event('updateStatus')  //新建和调用updateStatus事件对象
              ->append(array($this, 'updateStatusCallback')); //添加处理器
    }
</pre>
        （3）预先设置事件
                除了使用event()来添加或获取事件，还可以在外层预先设置事件。
                <span class="STYLE1">event+事件名称(eventName)</span>
                其中事件名称首字母要大写。
<pre class="brush: php;">
class IndexController extends Module
{
    public function __action()
    {
         Test::eventUpdateStatus()  //新建和调用updateStatus事件对象
              ->append(array($this, 'updateStatusCallback')); //添加处理器
    }
}
</pre>
<pre>
<strong>三、添加事件回调函数</strong>
        1、单个添加回调函数或对象
                使用append()方法注册回调函数，可以注册多次。
                        <span class="STYLE1">append(callback[, args])</span>
                参数说明：
</pre>
<table>
    <tr class="head">
        <td width="90">名称</td>
        <td width="400">描述</td>
    </tr>
    <tr>
        <td>callback</td>
        <td>必填。回调函数，和call_user_func_array()类似，指定的是函数名、方法数组，还可以是类名或对象。</td>
    </tr>
    <tr>
        <td>args</td>
        <td>可选。这是一个动态参数。可用来设置名称和优先级。</td>
    </tr>
</table>
                （1）回调函数

<pre class="brush: php;">
namespace app\services;

use Base\DatabaseModel;

class OrdersService extends DatabaseModel
{
    public function registerEvents()
    {
        //注册事件和处理器
        $this->event('afterUpdateStatus')
             ->append('writeUserLog') //指定已存在的函数名
             ->append(array('\app\services\UserLog', 'writeLog')); //指定方法名
    }
}
</pre>
                         以下是其中\app\services\UserLog的writeLog回调函数：

<pre class="brush: php;">
use Ocara\Core\Base;

class UserLog extend Base
{
    /**
     * 事件回调处理函数
     */
    public function writeLog($order, $oldStatus, $event)
    {
         /*记录订单状态日志*/
         $this->log->writeLog('order ' . $order->id . ' is successly updated to ' . $oldStatus);
    }
}
</pre>
                （2）回调类或对象
                        除此以外，框架还支持直接指定一个类或对象，然后回调它的handle()方法。

<pre class="brush: php;">
    public function registerEvents()
    {
        //注册事件和处理器
        $this->event('afterUpdateStatus')
             ->append('\app\services\OrderStatusLog') //指定类名
             ->append(new \app\services\OrderStatusLog()); //指定对象
    }
</pre>
                        这个对象类必须继承Ocara\Core\Middleware中间件基类。
                                <span class="STYLE1">handle(params, ... [,event , eventTarget])</span>
                        前面参数是每个事件调用时传递的自定义参数。
                        最后的两个参数必是evnet和eventTarget，分别是事件对象和触发事件的源对象，可选参数。

<pre class="brush: php;">
namespace Events\Callback;

use Ocara\Core\Middleware;

class OrderStatusLog extends Middleware
{
    /**
     * 事件回调处理函数
     */
    public function handle($order, $oldStatus, $event)
    {
         /*存入订单状态日志表*/
         $orderStatus = new \app\model\database\OrderStatusLog();
         $orderStatus->oldStatus = $oldStatus;
         $orderStatus->newStatus = $order->status;
    }
}
</pre>
                    （3）设置名称和优先级
                        如果append()有3个参数，第2个参数表示名称，第3个参数表示优先级；如果只有2个参数，第2个参数表示优先级。
                        注意：<strong>事件处理器会按照优先级降序，然后按添加顺序升序执行。</strong>

<pre class="brush: php;">
    public function registerEvents()
    {
        //注册事件和处理器
        $this->event('afterUpdateStatus')
             ->append('\app\services\OrderStatusLog', 1) //仅指定优先级
             ->append(new \app\services\OrderStatusLog(), 'order_status_log', 2); //指定名称order_status_log和优先级2
    }
</pre>

        2、批量绑定回调函数
                还可以用bindEventHandler()绑定一个对象，它包含了与事件名称相同的方法函数，可以批量添加回调函数。
                注：append()和bindEventHandler()可以同时使用，会按先后顺序添加回调函数。
                        <span class="STYLE1">bindEventHandler(eventHandler)</span>
                其中eventHandler可以是类名或对象。

<pre class="brush: php;">
namespace User;

/**
 * 用户事件处理器
 */
class UserHandler extends DatabaseModel
{
    /**
     * 显示前
     */
    public function beforeShow($userName, $event, $eventTarget)
    {
        echo 'beforeShow', PHP_EOL;
    }

    /**
     * 显示完
     */
    public function afterShow($userName, $event, $eventTarget)
    {
       echo 'afterShow';
    }

    public function other()
    {
       echo 'other';
    }
}

class User extends Base
{
    public function __construct()
    {
        $userModel->bindEventHandler('\User\UserHandler'); //用类名绑定处理器对象
        $userModel->bindEventHandler(new \User\UserHandler()); //用对象绑定处理器对象
    }

    public function show($userName)
    {
         $this->fire('beforeShow', array($userName)); //触发显示前事件
         echo $userName, PHP_EOL;
         $this->fire('afterShow', array($userName)); //触发显示后事件
    }
}

$user = new User();
$user->show('user1');
</pre>
                会显示为：
                beforeShow
                user1
                afterShow

        2、设置默认处理器
                还可以用setDefault()来设置一个默认处理器，当调用append()方法时会被覆盖掉。
                注：append()和bindEventHandler()可以同时使用，会按先后顺序添加回调函数。
                        <span class="STYLE1">setDefault(callback)</span>
                其中callback是回调函数、类或对象，同append()方法。

<pre class="brush: php;">
    public function registerEvents()
    {
        //注册事件和处理器
        $this->event('afterUpdateStatus')
             ->setDefault('\app\services\OrderStatusLog'); //设置默认处理器
    }
</pre>

<strong>四、修改、删除处理器</strong>
        上述介绍了添加处理器，还可以修改、删除处理器。可以使用名称和序号来指定处理器。
        有以下方法：
                （1）get(name)：获取某个处理器。其中name是定义的名称或者序号；

<pre class="brush: php;">
    public function registerEvents()
    {
        //添加处理器
        $this->event('afterUpdateStatus')
             ->append('\app\services\OrderStatusLog', 'order_status_log')
             ->append('\app\services\SendSms');

        //获取第1个处理器
        $logHandler = $this
             ->event('afterUpdateStatus')
             ->get('order_status_log');

        //获取第2个处理器
        $smsHandler = $this
             ->event('afterUpdateStatus')
             ->get(2); //获取第2个处理器
    }
</pre>
                （2）has(name)：检测是否存在某个处理器。name参数类似；

<pre class="brush: php;">
//检测是否存在处理器order_status_log
$exists = $this
     ->event('afterUpdateStatus')
     ->has('order_status_log');

//返回存在第2个处理器的指针
$index = $this
     ->event('afterUpdateStatus')
     ->has(2);
</pre>
                （3）modify(name, callback)：修改处理器。name参数类似，callback参数与append()一样；

<pre class="brush: php;">
//修改处理器order_status_log的回调类
//也可以使用modify(2, 'app\service\NewOrderStatusLog')
$exists = $this
     ->event('afterUpdateStatus')
     ->modify('order_status_log', 'app\service\NewOrderStatusLog');
</pre>
                （4）setPriority(name, priority)：修改优先级。name参数类似，priority为优先级。

<pre class="brush: php;">
//修改处理器order_status_log的回调类
$exists = $this
     ->event('afterUpdateStatus')
     ->setPriority('order_status_log', 15); //也可以使用setPriority(2, 15)
</pre>
                （5）delete(name)：删除处理器。name参数类似。

<pre class="brush: php;">
//修改处理器order_status_log的回调类
$exists = $this
     ->event('afterUpdateStatus')
     ->delete('order_status_log'); //也可以使用delete(2)
</pre>


<strong>五、事件触发</strong>
        <span class="STYLE1">fire(eventName[, params])</span>
        其中，eventName是事件名称，params是触发时传递给回调函数的参数。

<pre class="brush: php;">
namespace app\services;

use Base\DatabaseModel;

class OrdersService extends DatabaseModel
{
    public function updateStatus($orderId, $extraData)
    {
        $order = new \app\model\database\Orders();
        $order->select($orderId);

        $oldStatus = $order->status;
        $newStatus = 1;

        $order->status = $newStatus;
        $order->save($extraData);

        //触发事件
        $args = array($order, $oldStatus);
        $order->fire('afterUpdateStatus', $args);
    }
}
</pre>

<strong>六、事件中断</strong>
        在事件的多个处理器中，可以使用stop()来中断事件的执行。
                <span class="STYLE1">stop()</span>

        使用isRunning()判断是否在运行中
                <span class="STYLE1">isRunning()</span>

<pre class="brush: php;">
namespace app\services;

use Ocara\Core\Middleware;

class OrderStatusLog extends Middleware;
{
    public function handle($order, $oldStatus, $event)
    {
        if (empty($orderId)){
            $event->stop(); //中断事件
        }

        if ($event->isRunning()) { //事件是否在运行中
             /*存入订单状态日志表*/
        }
    }
}
</pre>

</pre>
</pre>
</body>
</html>
