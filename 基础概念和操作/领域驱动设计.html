<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>领域驱动设计</title>
    <script type="text/javascript" src="../syntax/scripts/shCore.js"></script>
    <script type="text/javascript" src="../syntax/scripts/shBrushPhp.js"></script>
    <link type="text/css" rel="stylesheet" href="../style/base.css" />
    <link type="text/css" rel="stylesheet" href="../syntax/styles/shCoreDefault.css"/>
    <script type="text/javascript" src="../treeview/base.js"></script>
    <style type="text/css">
        <!--
        .STYLE1 {
            color: #0000FF;
            font-weight: bold;
        }
        -->
    </style>
</head>
<body alink=#ff0000>
<pre><h2>一、领域驱动设计的简单理解</h2>

     对于领域驱动设计的理论概念网上有很多不错的文章，也有相关书籍。本文不做长文描述。
     简单地说，领域驱动设计是将业务需求从技术角度转变为从领域角度去理解划分和实现。
在这当中，最为核心地有实体和值对象的概念。实体和值对象有两个不同点：
     （1）实体可读可写，并且可以持久化；每个具体的实体都有一个唯一的标识，类似数据表中的主键ID。
    （2）值对象只读不写，不能持久化；每个具体的值对象没有唯一的标识。因为它只作为一个对象类型的值，不需要关心它的编号。

    <h2>二、本框架中的领域设计</h2>

<strong>1、实体</strong>

    根据实体的特点，本框架特将实体分为物理实体和逻辑实体。
    （1）物理实体
    就是需要持久化的实体。既然要持久化，所以大多保存到数据库或缓存。正好对应数据库表中的一行，类似于ORM模型。
    所以本框架的ORM模型作为物理实体模型，并且它必须继承自相应的模型类。这样可以实现代码复用，并且他们都属于模型层（Model）。
    用户表模型类User：
<pre class="brush: php;">
namespace app\dal\models\User;

use Base\DatabaseModel;

class User extends DatabaseModel
{
    /**
     * 获取用户列表
     */
    public function getList($conditions, $options = array())
    {
        $result = array();

        /*这里写搜索代码*/

        return $result;
    }

    /**
     * 获取用户列表
     */
    public function getDetail($userId)
    {
        $result = array();

        /*这里写查询代码*/

        return $result;
    }
}

</pre>
用户表实体模型类：
<pre class="brush: php;">
namespace app\dal\entities\UserEntity;

use app\dal\models\User AS UserModel;

class UserEntity extends UserModel
{
    protected function beforeCreate()
    {
        $this->create_time = time();
    }

    protected function afterUpdate()
    {
        if ($this->hasChange('user_type')) { //有更新用户类型字段user_type
            if ($this->user_type == 3) {
                $this->remark = '代理商';
            } elseif ($this->user_type == 2) {
                $this->remark = '企业';
            } else {
                $this->remark = '个人';
            }
        }
    }
}
</pre>

    具体使用时，对于批量的增删改查或者非ORM模型的单记录查询，都使用模型；而ORM模型必须使用实体。
<pre class="brush: php;">
//使用模型
$useModel = new \app\dal\models\User;
$userList = $useModel->getList(array('status' => 1)); //获取列表
$userDetail = $useModel->getDetail(1); //获取详情

$where = array('status' => 2);
$data = array('status' => 3);
$userModel->update($data, $where); //批量更新记录

//使用ORM实体
$userEntity = new \app\dal\entities\UserEntity;
$userEntity->status = 1;
$userEntity->save(); //ORM实体模型保存数据

</pre>

   （２）逻辑实体
    不需要持久化的实体，有唯一标识。一般作为临时使用地，有点类似于数据传输对象DTO，只不过我们用实体来表示，而不用DTO。
    本框架仅提供一个逻辑实体的基类Ocara\Core\BaseEntity，它提供了fill()和toArray()两个函数方法。
<pre class="brush: php;">
namespace AliPay;

class AliOrder extends User
{
    public $orderSn;
    public $payType;
    public $notifyUrl;

    /*... ...*/

    public function setNotifyUrl($url) {
        $this->notifyUrl = $url . '/pay/notify';
    }

    public function getPayType() {
        /*... ...*/
    }
}

$data = array(
    'orderSn' => '230003248945',
    'payType' => 3
);

$aliOrder = new AliOrder();
$aliOrder->fill($data); //填充数据
$aliOrderEntity = $aliOrder->toArray(); //返回数组

</pre>

<strong>2、值对象</strong>
    根据值对象的概念和特点。值对象在本框架中一般作为一个enum类型字段或者状态字段的常量配置使用。
    比如订单状态字段：
<pre class="brush: php;">
namespace app\dal\values;

class OrderStatus
{
    const SUBMITED = 0; //已生成
    const PAID = 10; //已支付
    const CANCEL = 20; //已取消
    const FINISHED = 30; //已完成
    const SENT = 40; //已发货
    const BACKING = 50; //退货中
    /*... ...*/

    //状态描述配置
    protected static $_statusDesc = array(
        self::SUBMITED => '已生成',
        self::PAID => '已支付',
        /*... ...*/
    );

    /**
     * 获取状态描述
     */
    public function getStatusDesc($name = null)
    {
        if (func_num_args()) {
            return !empty(self::$_statusDesc[$name]) ? self::$_statusDesc[$name] : '未知状态';
        }
        return self::$_statusDesc; //获取所有描述
    }
}
</pre>
    比如枚举类型user_type用户类型字段
<pre class="brush: php;">
namespace app\dal\values;

class UserType
{
    const PERSON = 1; //个人
    const ENTERPRISE = 2; //企业
    const AGNET = 3; //代理商
    /*...*/

    /**
     * 获取用户类型描述
     */
    pubic function getTypeDesc()
    {
        //使用多语言配置
        return array(
            self::PERSON => ocLang('user_type_person'), //个人
            self::ENTERPRISE => ocLang('user_type_enterprise'), //企业
            self::AGNET => ocLang('user_type_agent'), //代理商
        );
    }
}
</pre>

<strong>3、服务</strong>
通过服务提供器可以实现领域驱动设计中的服务。

</pre></body></html>
